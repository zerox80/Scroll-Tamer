(function() {
  'use strict';

  // Fixed global slowdown factor
  const FACTOR = 0.2; // 20% of native
  if (Math.abs(FACTOR - 1) <= 1e-3) return;

  function closestScrollableY(el) {
    let node = el;
    const visited = new Set();
    const doc = document.scrollingElement || document.documentElement;
    while (node && node !== document.body && node !== document.documentElement) {
      if (visited.has(node)) break;
      visited.add(node);
      try {
        // Fast path: only if content is taller than the viewport, check overflow style
        const taller = node.scrollHeight > node.clientHeight + 1;
        let canY = false;
        if (taller) {
          const cs = getComputedStyle(node);
          const oy = cs.overflowY;
          canY = (oy === 'auto' || oy === 'scroll' || oy === 'overlay');
        }
        if (canY) return node;
      } catch {}
      if (node.parentElement) {
        node = node.parentElement;
      } else {
        const root = node.getRootNode && node.getRootNode();
        node = (root && root.host) ? root.host : null;
      }
    }
    return doc;
  }

  function withInstant(el, fn) {
    try {
      const prevBeh = el.style.getPropertyValue('scroll-behavior');
      const prevBehPri = el.style.getPropertyPriority('scroll-behavior');
      const prevSnap = el.style.getPropertyValue('scroll-snap-type');
      const prevSnapPri = el.style.getPropertyPriority('scroll-snap-type');
      el.style.setProperty('scroll-behavior', 'auto', 'important');
      el.style.setProperty('scroll-snap-type', 'none', 'important');
      fn();
      setTimeout(() => {
        try {
          if (prevBeh) el.style.setProperty('scroll-behavior', prevBeh, prevBehPri || ''); else el.style.removeProperty('scroll-behavior');
          if (prevSnap) el.style.setProperty('scroll-snap-type', prevSnap, prevSnapPri || ''); else el.style.removeProperty('scroll-snap-type');
        } catch {}
      }, 320);
    } catch {
      fn();
    }
  }

  // Passive correction coalescing (one measurement per frame)
  let __pScheduled = 0;
  let __pPrevDoc = 0;
  let __pPrevTar = 0;
  let __pCand = null;

  function onWheelPassive(e) {
    try {
      if (e.ctrlKey || e.altKey) return; // allow pinch/bypass
      if (e.defaultPrevented) return;
      // Bypass when user explicitly requests horizontal (Shift+wheel)
      if (e.shiftKey) return;
      const doc = document.scrollingElement || document.documentElement;
      if (!__pScheduled) {
        __pScheduled = 1;
        __pCand = closestScrollableY(e.target) || doc;
        try { __pPrevDoc = doc.scrollTop; } catch { __pPrevDoc = 0; }
        try { __pPrevTar = __pCand.scrollTop; } catch { __pPrevTar = 0; }
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try {
              const movedDoc = (() => { try { return doc.scrollTop - __pPrevDoc; } catch { return 0; } })();
              const movedTar = (() => { try { return __pCand.scrollTop - __pPrevTar; } catch { return 0; } })();
              const useTar = Math.abs(movedTar) >= Math.abs(movedDoc);
              const chosen = useTar ? __pCand : doc;
              const moved = useTar ? movedTar : movedDoc;
              if (!moved) return; // nothing moved
              const correction = moved * (FACTOR - 1);
              if (Math.abs(correction) < 0.3) return; // threshold to avoid micro-jitter
              let needInstant = false;
              if (Math.abs(correction) > 2) {
                try {
                  const cs = getComputedStyle(chosen);
                  const beh = cs.getPropertyValue('scroll-behavior');
                  const snap = cs.getPropertyValue('scroll-snap-type');
                  needInstant = (beh && beh.trim() && beh.trim() !== 'auto') || (snap && snap.trim() && snap.trim() !== 'none');
                } catch {}
              }
              const apply = () => {
                try {
                  chosen.scrollTop += correction;
                } catch {
                  try { chosen.scrollBy({ left: 0, top: correction, behavior: 'auto' }); } catch {}
                }
              };
              if (needInstant) withInstant(chosen, apply); else apply();
            } catch {}
            finally {
              __pScheduled = 0;
              __pCand = null;
            }
          });
        });
      }
    } catch {}
  }

  function normalizeDelta(e) {
    const LINE = 16;
    const PAGE = window.innerHeight || 800;
    const unit = e.deltaMode === 1 ? LINE : (e.deltaMode === 2 ? PAGE : 1);
    return { x: e.deltaX * unit, y: e.deltaY * unit };
  }

  function canScrollY(el, delta) {
    try {
      const max = Math.max(0, el.scrollHeight - el.clientHeight);
      const top = el.scrollTop;
      if (delta < 0) return top > 0.5;
      return top < (max - 0.5);
    } catch { return true; }
  }

  // Coalesce active-mode updates into a single scroll per animation frame
  const __accY = new Map(); // Element -> accumulated dy
  const __remY = new WeakMap(); // Element -> fractional remainder
  let __rafId = 0;
  function __flush() {
    __rafId = 0;
    __accY.forEach((dy, el) => {
      __accY.delete(el);
      // Combine with fractional remainder and quantize to integer pixels
      let rem = 0;
      try { rem = __remY.get(el) || 0; } catch {}
      const total = dy + rem;
      // Ignore ultra-small totals to avoid micro work; keep remainder
      if (Math.abs(total) < 0.5) { __remY.set(el, total); return; }
      const out = total > 0 ? Math.floor(total) : Math.ceil(total);
      const newRem = total - out;
      __remY.set(el, newRem);
      if (!out) return;
      try {
        el.scrollTop += out;
      } catch {
        try { el.scrollBy({ left: 0, top: out, behavior: 'auto' }); } catch {}
      }
    });
  }
  function __scheduleFlush() { if (!__rafId) __rafId = requestAnimationFrame(__flush); }

  // Keep a stable target per gesture to avoid switching containers mid-burst
  let __gTarget = null;
  let __gTimer = 0;
  const __GESTURE_IDLE = 280;
  function __touchGesture() {
    // Gesture idle timer
    try { clearTimeout(__gTimer); } catch {}
    __gTimer = setTimeout(() => { __gTimer = 0; __gTarget = null; }, __GESTURE_IDLE);
  }

  function onWheelActive(e) {
    try {
      if (e.ctrlKey || e.altKey) return; // allow pinch/bypass
      const doc = document.scrollingElement || document.documentElement;
      const n = normalizeDelta(e);
      if (!n || !n.y) return;
      // Bypass when user explicitly requests horizontal (Shift+wheel)
      if (e.shiftKey) return;
      const dy = n.y * FACTOR;
      if (Math.abs(dy) < 0.1) return;
      e.preventDefault();
      let chosen = null;
      if (__gTarget && canScrollY(__gTarget, dy)) {
        chosen = __gTarget;
      } else {
        const t = closestScrollableY(e.target) || doc;
        const cand = canScrollY(t, dy) ? t : doc;
        chosen = cand;
        __gTarget = cand;
      }
      __accY.set(chosen, ( __accY.get(chosen) || 0 ) + dy);
      __scheduleFlush();
      __touchGesture();
    } catch {}
  }

  // Domain-specific passive override disabled to ensure consistent slowdown everywhere
  const USE_INTERCEPT = (FACTOR < 0.75);
  if (USE_INTERCEPT) {
    window.addEventListener('wheel', onWheelActive, { passive: false, capture: true });
  } else {
    window.addEventListener('wheel', onWheelPassive, { passive: true, capture: false });
  }
})();

